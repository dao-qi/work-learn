# 程序员修炼之道

1. 责任
   不要害怕承认自己的无知或错误，犯错或者是判断出错时，诚实的承认，而不应该为自己找各种撇脚理由。而是提供选择(说明能够做什么挽回局面)。
2. 不要容忍破窗户
   发现了糟糕的代码设计或者决策就立即改正，不要容忍，否则只会越积越多，最终无法处理。这一点我自己在写项目的时候也深有体会。这是一种心理因素，当环境都很美好时，自然也不忍心将其变差。
3. 做变化的催化剂
   变化要有一个开头，之后就会简单了。所以可以自己做开头，也可以精心策划一个开头。
4. 关注大图景
   持续不断的关注周围发生的事情，而不仅仅是自己正在做的事情。
5. 足够好
   在获取需求时应该考虑软件的质量，用户到底需要一个多好的软件。
6. 投资知识资产
   当前掌握的技术总有被淘汰的一天，需要不断学习，广泛学习，甚至判断将来即将流行的技术并学习。另外，尽可能钻研那些变化不是那么快的知识(基础知识)。
   扩充知识的途径
   > **每年至少学习一门新语言** > **每季度阅读一本技术书籍**。书店里摆满了许多书籍，讨论与你当前的项目有关的有趣话题。一旦你养成习惯，就一个月读一本书在你掌握了你正在使用的技术之后，扩宽范围，阅读一些与你的项目无关的书籍
   > **也要阅读非技术书籍**。记住计算机是由人使用的，这十分重要,不要忘了等式中人这一边.
   > **上课**。在木地的学院或大学、或是将要来临的下一次会展上寻找有趣的课程.
   > **参加本地用户组织**。不要只是去听讲，而要主动参与.
   >
   > **试验不同的环境**。如果你只在 Windows 工作。就在家玩一玩 Unix 如果你只用过 makefile 和编辑器，就试一试 IDE,反之亦然.
   > **跟上潮流**。订阅商务杂志和其他期刊
   > **上网**,查看论文,博客,论坛等
7. 批判的思考
8. 善于向前辈请教
   无论是现实生活中,还是网络上.表达感谢.
9. 交流
   > 知道自己想要表达什么.
   > 了解听众.同一个项目,不同的听众感兴趣的点不一样.
   > 选择合适的交谈时机.
   > 选择风格,是大段文档还是简略的备忘录,不同的人适合不同的风格.
   > 文档美观.
   > 让听众参与文档制作,更早的获取反馈.
   > 学会倾听.
   > 及时回复他人

## 第二章

1. 重复
   不要重复,重复将造成维护困难.比如在多个地方写了一些相同的代码,当这些代码逻辑变化时,每一处都需要修改.
2. 正交性
   平面坐标系中 x,y 轴正交,沿着某一个轴前进,另一个轴的坐标不变.在软件中体现为解耦,如果两个或更多事物变化而不会影响其他事物,这些事物就是正交的.
   分层次或分模块正是正交性的体现.
   维持正交性的方式:

   - **让代码保持解构**,不要暴露不必要的接口,也不依赖与其他模块的实现.
   - **避免使用全局变量**
   - **避免编写相似的方法**相似方法可以使用策略模式.

3. 曳光弹与模块开发

   - 曳光方式的开发要求先写少量代码实现关键的功能，验证该功能，然后在这个基础上不断完善。曳光模式与原型模式有显著区别，原型模式确认了原型之后原型就会被扔掉。原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。那才是原型制作的要点所在
   - 模块开发则繁重得多。要求每个模对着黑暗开发，最终组合成一个完成的应用。

4. 估算
   - 熟悉估算，可以评估可行性，知道哪些子系统需要优化

## 第三章 工具

1. **纯文本**，纯文本由可打印宁符组成，人可以直接阅读和理解其形式。持久地存储知识的最佧格式是纯文本。
2. 使用 **shell**
   - 学会使用 shell，gui 的好处是所见即所得，坏处是所见即全部的所得。
   - shell 命令可以组合成 脚本完成自动化的功能。
3. **编辑器**

   - 最好是精通一种编辑器，并将其用于所有编辑任务：代码。文档。备忘录，系统管理，等等。如果不坚持使用一种编辑器，就可能会面临混乱，你可能必须用每种语言的 IDE 内建的编辑器进行编码，用“ all-in-one"办公软件编辑文档，或是用另一种内建的编辑器发送电子邮件。甚至你用于在 shell 中编辑命令行的键击都有可能不同。如果你在每种环境中有不同的编辑约定和命令，要精通这些环境中的任何一种都会很困难。
   - 选一种编辑器，彻底了解它，并将其用于所有的编辑任务。如果你用一种编辑器或一组键绑定）进行所有的文本编辑活动，你就不必停下来思考怎样完成文本操纵必需的键击将成为本能反应。编辑器将成为你双手的延伸。

4. **源码控制**
   - 总是使用源码控制(版本控制)，即使你的团队只有你一个人，你的项目只需一周时间；即使那是“用过就扔”的原型；即使你的工作对象并非源码；确保每样东西都处在源码控制之下—一文档、电话号码表，给供应商的备忘录、 makefile 构建与发布流程、烧制 CD 母盘的 shel 小脚本—每样东西，我们例行公事地对我们敲入的每一样东西进行源码控制包括本书的文本）即使我们不是在开发项目，我们的日常工作也被安全地保存在仓库中。
5. **调试**
   - 遇到 bug 不要恐慌，某样东西出错时，你感到吃惊的程度与你对正在运行的代码的信任及信心成正比。这就是为什么，在面对“让人吃惊”的故障时，你必须意识到你的一个或更多的假设是错的。不要因为你“知道”它能工作而轻易放过与 bug 有牵连的例程或代码。证明它。用这些数据，这些边界条件在这个语境中证明它。
   - 不要假定，要证明。
6. **代码生成器**
   - 被动代码生成器只运行一次来生成结果然后结果就变成了独立的一它与代码生成器分离了。
   - 主动代码生成器在每次需要其结果时被使用结果是用过就扔的一它总是能由代码生成器重新生成。主动代码生成器为了生成其结果，常常要读取某种形式的脚本或控制文件。

## 第四章 没有完美的程序

1. 面向接口编程
2. 死程序不说谎
   - 我们很容易掉进“它不可能发生”这样一种心理状态。我们中的大多数人编写的代码都不检查文件是否能成功关闭，或者某个跟踪语句是否已按照我们的预期写出而如果所有的事情都能如我们所愿，我们很可能就不需要那么做一这些代码在任何正常的条件都不会失败。但我们是在防卫性地编程。我们在程序的其他部分中查找破坏堆栈的“淘气指针”，我们在检查确实加载了共享库的正确版本。
   - 所有的错误都能为你提供信息。你可以让自己相信错误不可能发生，并选择忽略它。但与此相反，注重实效的程序员告诉自己，如果有一个错误，就说明非常、非常槽糕的事情已经发生了。
3. 程序出现异常时尽早停止。
4. 断言式编程

   - 断言检查的是绝不可能发生的事情，不要用断言代替异常处理。
   - 保持断言开着。

5. 利用资源时要有始有终，记得关闭资源。

## 第五章 灵活

1. 解耦

   - 把你的代码组织成最小组织单位（模块并限制它们之间的交互、如果随后出于折中必须膂换某个模块、其他模块仍能够继续工作。
   - 函数的得墨忒耳法则试图使任何给定程序中的模块之间的耦合减至最少，它设法阻止你为了获得对第三个对象的方法的访问而进入某个对象。
   - 使用得墨忒耳法则将使你的代码适应性更好、更健壮，但也有代价：作为“总承包人”，你的模块必须直接委托并管理全部子承包人，而不牵涉你的模块的客户在实践中，这意味菥你将会编写大量包装方法，它们只是把请求转发给被委托者这些包装方法既会带来运行时代价。也会带来空间开销，在有些应用中，这可能会有重人影响—甚至会让你无法承受。

2. 源程序设计
   - 动态配置。首先，我们想要让我们的系统变得高度可配置。不仅是像屏幕颜色和提示文本这样的事物，而且也包括诸如算法，数据库产品，中间件技术和用户界面风格之类更深层面的选择。这些选择应该作为配置选项、而不是通过集成或工程（ engineering 实现
   - 元数据到底是什么？严格地说，元数据是关于数据的数据。最为常见的例子可能是数据库 schema 或数据词典。 schema 含有按照名称、存储长度及其他属性，对字段（列）进行描述的数据你应该能访问和操纵这些信息，就像对数据库中的任何其他数据一样
3. 时间耦合

   - 许多任务，我们思考的逻辑是先做这个再做那个，这样耦合性比较高。降低这样的耦合性，需要分析工作流，改善并发性。
     架构中使用队列进行通信。
   - 首先，必须对任何全局或静态变量加以保护，使其免于并发访问。现在也许是时候问问你自己，你最初为何需要全局变量的。此外，不管调用的次序是什么，你都需要确保你给出的是一致的状态信息。例如，何时查询你的对象的状态才是有效的？如果你的对象在某些调用之间处在无效状态，你也许就是在依赖一个巧合：没有人会在那个时间点调用你的对象。

4. mvc
   - 尽管在典型悄况下、MvC 是在 GUI 开发的语境中教授的，它其实是种通用的编程技术视图是对模型（也许是其子集）的种解释—一它无需是囹形化的控制器史是种协调机制，不一定要与仟何种类的输入设备有关
   - 模型。表小目标对象的抽象数据模型、模型对任何视图或控制器都没有直接的了解
   - 视图。解释模型的方式它订阅模型中的变化和来自控制器的逻辑事件 -控制器。控制视图、并向模型提供新数据的途径。它既向模型、也向视图发布事件
5. 黑板 -黑板系统让我们完仝解除了我们的对象之间的耦合。并提供了一个“论坛”，知识消费者和广者可以在那甲匿名、异步地交换数据：如你可能会猜想的那样，它还减少了我们必须编写的代码的数量

## 第六章 编码

1. 巧合编程

   - 总是意识到你在做什么。Fred 让事情慢慢失去了控制，直到最后被煮熟，就像“石头汤与煮青蛙”里的青蛙一样
   - 不要盲目地编程试图构建你不完全理解的应用，或是使用你不熟悉的技术，就是希望自己被巧合误导
   - 按照计划行事，不管计划是在你的头脑中，在鸡尾酒餐巾的背面，还是在某个 CASE 具生成的墙郡么大的输出结果上。
   - 依靠可靠的事物不要依靠巧合或假定如果你无法说出各种特定情形的区别，就假定是最坏的
   - 为你的假定建立文档“按合约编程”有助于澄清你头脑中的假定，并且有助于把它们传达给别人。
   - 不要只是测试你的代码，还要测试你的假定、不要猜测：要实际尝试它。编写断言测试你的假定如果你的断言是对的，你就改善了代码中的文档。如果你发现你的假定是错的，那么就为自己庆幸吧
   - 为你的工作划分优先级。把时间花在重要的方面；很有可能，它们是最难的部分如果你的基本原则或基础设施不正确，再花哨的铃声和口哨也是没有用的
   - 不要做历史的奴求不要让已有的代码攴配将来的代码如果不再适用。所有的代码都可被替换即使是在一个程序中、也不要让你经做完的事情约束你下步要做的事情——准备好进行重构。这一决策可能会影响项目的进度。

2. 算法速率
   - 我们发现，只要我们編写的是含有循环或递归调用的程序，我们就会下意识地计算运行间和内存需求这很少是形式过程，而是快速地确认我们任做的中情在各种情形下是有意义的。但是，有时我们确实会发现自己在进行更为详细的分析那就是用上 O()表示法的时候了
   - 常见算法的复杂度
     - 简单循环 n
     - 嵌套循环 n<sup>2<sup>
     - 二分法 log(n)
     - 分治法 nlog(n)
   - 还需要在选择适当算法时注重实效—最快的算法对于你的工作并非总是最好的.假定输入集很小，直截了当的插入排序的性能将和快速排序一样好，而你用于编码和调试的时间将更少如果你的选择的算法有高品的设置开销，你也需要注意对于小输入集，这些设置时间可能会使运行时间相形见绌，并使得算法变得不再适用.
3. 重构
   - 什么时候进行重构：
     - 重复
     - 违反正交性设计
     - 知识过时
     - 性能很差
   - 早重构，常重构
   - 怎样重构：
     - 1.不要试图在重构的同时增加功能。
     - 2.在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。这样，如果你的改动破坏了任何东西，你就能很快知道。
     - 3.采取短小、深思熟虑的步骤：把某个字段从一个类移往另一个，把两个类似的力法融合进超类中。重构常常涉及到进行许多局部改动，继而产生更大规模的改动：如果你使你的步骤保持短小，并在每个步骤之后进行测试，你将能够避免长时间的调试。
4. 测试
   - 当你设计模块、甚或是单个例程时，你应该既设计其合约，也设计测试该合约的代码。通过设计能够通过测试，并履行其合约的代码，你可以仔细地考虑边界条件和其他非如此便不会发现的问题。没有什么修正错误的方法比从一开始就避免发生错误更好。事实上，通过在你实现代码之前构建测试，你必须在你确定采用某个接口之前先对它进行试验。
5. 邪恶的向导
   不要使用自己不理解的代码生成器。

## 第七章 项目开始前

1. 需求的坑
   - 需求应该去挖掘，它们被大量假设和误解包围。仅仅收集需求只会流于表面。
   - 需求是对需要完成某件事情的陈述。
   - 用户可能会这样陈述上面列出的第一条陈述：“只有员丁的上级和人事部门才可以查看员丁的档案这个陈述真的是需求吗？今天也许是，但它在绝对的陈述中嵌入了商业政策。政策会经常改变，所以我们可能并不想把它们硬性地写入我们的需求、我们的建议是，把这些政策的文档与需求的文档分开，并用超链接把两者连接起来。使需求成为一般陈述，并把政策信息作为例子发给开发者他们需要在实现中支持的事物类型的例子，最后，政策可以成为应用中的儿数据。
   - 了解用户需求的一个有效方法是成为用户。
   - 抽象比具体的实现细节更为长久。
   - 通过把需求制作成超文本文档。我们可以更好地满足不同听众的需要—我们可以给每个读者他们想要的东西。项目出资人可以在高层的抽象层面上巡视，以确保商业目标得以实现。程序员可以使用超链接“钻入”越来越深入的细节中
2. 解开不可能解开的谜题
   - 解决某些看是无解的难题的关键是找到真正的约束。
   - 在面对棘手的问题时，列出所有在你面前的可能途径。不要排除任何东西，不管它听起来有多无用或愚蠢。现在，逐一检查列表中的每一项，并解释为何不能采用某个特定的途径。
   - 对你的各种约束进行分类，并划定优先级。木匠开始做活路时，会首先锯出最长的木料，然后再从剩下的木头中锯出较小的木料。按照同样的方式，我们想先确定最为严格的约束，然后冉在其中考虑其余的约束
3. 等你准备好
   - 倾听反复出现的疑虑—等你准备好再开始
   - 编写程序规范就是把需求归约到程序员能够接管的程度的过程、这是一个交流活动、旨在解释并澄清系统的需求，比如消除主要的歧义除了与最初实现的开发者交淡以外，规范还是留给未来进行代码维护和增强的几批程序员的记录。规范也是与用户的约定—是对他们的需要的汇编，也是一份隐含的合约：最终系统将会符合该合约的要求。编写规范是一项重要职责。
   - 规范和实现不过是同一个过程—设法捕捉和编纂需求—的不同方面。每一步都应该直接流入下一步，没有人为制造的界限。你将会发现，健康的开发过程鼓励把来自实现与测试的意见反馈到规范中。

## 第八章 注重实效的项目

1. 注重实效的团队
   - 利用第一章提到的一些原则。
2. 无处不在的自动化
   - 尽量将重复性工作写成脚本，人的重复性相比于计算机的重复性来说太弱。
3. 无情的测试
4. 全都是写
   - 注重实效的程序员会把文档当作整个开发过程的完整组成部分加以接受。不进行重复劳动，不浪费时间，并且把文档放在手边--如果可能，就放在代码本身当中，文档的撰写就可以变得更容易。
5. 极大的期望
6. 傲慢与偏见
   - 注重实效的程序员不会逃避责任。相反，我们乐于接受挑战。乐于使我们的专业知识广为人知如果我们在负责一项设计，或是一段代码，我们是在做可以引以自豪的工作。在自己的作品上签名。

本书给未来的学习方向指明了路径，怎样持续地保持竞争力。
正交性使得我对于耦合有了更清晰的认识。
某些看似增加工作量的工作(比如面向切口编程， 绝不要重复DRY)整体上是为了降低各模块之间的耦合，使得系统易于修改维护、易于扩展。
破窗理论、温水青蛙也给与我们警醒：代码中的不合理设计要及时修正;跳出本身的工作内容看待项目。
